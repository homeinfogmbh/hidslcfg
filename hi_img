#! /usr/bin/env python3
"""HOMEINFO Digital Signage Linux setup

Usage:
    hi_img (backup | restore) <device> <image>

Options:
    -h --help           Show this page.
    -v --version        Show version.
    --user=<user_name>  Specifies the setup user's name.
    --passwd=<passwd>   Specifies the setup user's password.
"""

from docopt import docopt
from sys import stderr
from getpass import getpass
from hashlib import sha256
from requests import get
from homeinfo.lib.strf import Terminal
from os import listdir
from os.path import isdir, join
import tarfile
from tempfile import NamedTemporaryFile

options = docopt(__doc__)

valid_ids_formats = ['<tid>.<cid>', '<cid>/<tid>']
image_dir = '/usr/local/share/homeinfo/images'
valid_hardware = ['amd', 'intel']
api_url = 'https://tls.homeinfo.de/termgr/setup'

format_info = '\n'.join(['', '    Valid identifier formats are:']
                        + [''.join(['    * ', f]) for f in valid_ids_formats])
hardware_info = '\n'.join(['', '    Valid hardware selections are:']
                          + [''.join(['    * ', h]) for h in valid_hardware])


class InvalidUserName(Exception):
    pass


class WrongPassword(Exception):
    pass


class NotAllowed(Exception):
    pass


def fail(err, *msgs, exit_code=3):
    """Print message to stderr and exit"""
    print(Terminal.red(Terminal.bold(err)), *msgs, file=stderr)
    exit(exit_code)


class Mode():
    """Partition backup mode"""

    CREATE = 0
    RESTORE = 1


class BlockDevice():
    """A UNIX-like block device wrapper"""

    def __init__(self, path):
        """Sets the device path"""
        self._path = path

    @property
    def path(self):
        """Returns the device path"""
        return self._path

    @property
    def mbr(self):
        """Gets master boot record of the device"""
        with open(self.device, 'rb') as dev:
            return dev.read(512)

    @mbr.setter
    def mbr(self, data):
        """Writes master boot record to the disk"""
        if len(data) != 512:
            raise ValueError('MBR must be exactly 512 bytes in size')
        else:
            with open(self.path, 'r+b') as dev:
                dev.seek(0)
                dev.write(data)

    def partition(self, n):
        """Get partition no. n"""
        return ''.join(self.path, str(n))


class PartitionImage():
    """Represents a partition image"""

    def __init__(self, file):
        """Loads a partition image from a backup file"""
        self._file = file

    @property
    def file(self):
        """Returns the backup file"""
        return self._file

    def create(self, device, label=None):
        """Creates a partition image"""
        with tarfile.open(name=self.file, mode='w') as archive:
            with NamedTemporaryFile('wb') as mbr:
                mbr.write(device.mbr)
            with NamedTemporaryFile('wb') as part0:
                pass  # TODO: Implement


class PartitionBackup():
    """Represents a partition backup"""

    @property
    def mbr(self):
        """Gets the master boot record of a device"""
        if self.mode == Mode.CREATE:
            pass  # TODO: Implement
        elif self.mode == Mode.RESTORE:
            return self.image.mbr

    @mbr.setter
    def mbr(self, data):
        """Writes the master boot record to the device"""
        pass    # TODO: Implement
     