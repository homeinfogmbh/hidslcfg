#! /usr/bin/env python3
"""Configure or reset a HIDSL device."""

from contextlib import suppress
from datetime import datetime
from enum import Enum
from getpass import getpass
from json import loads, dumps
from os import chdir, geteuid, getcwd
from pathlib import Path
from subprocess import DEVNULL, CalledProcessError, run
from sys import stderr, exit as exit_
from tempfile import TemporaryDirectory
from time import sleep

from docopt import docopt
import requests


__all__ = [
    'ProgramError',
    'InvalidCredentials',
    'Unauthorized',
    'APIError',
    'ValueMismatch',
    'APIClient',
    'Configurator']

DATETIME_FORMATS = ('%Y-%m-%dT%H:%M:%S', '%Y-%m-%dT%H:%M:%S.%f')
BOLD = '\033[1m{}\033[0m'

SYSTEMCTL = '/usr/bin/systemctl'
PING_HOST = '/usr/bin/ping -W 1 -c 5 {}'

VPN_CLIENT_DIR = Path('/etc/openvpn/client')
VPN_ARCHIVE = 'openvpn.tar.gz'
VPN_CFG = 'terminals'
VPN_SERVER = '10.8.0.1'
VPN_GRACETIME = 3
VPN_INST = '/usr/bin/tar xf {archive} -C {client_dir}'.format(
    archive=VPN_ARCHIVE, client_dir=VPN_CLIENT_DIR)
VPN_CLEAN = '/usr/bin/rm -f {}'.format(VPN_CLIENT_DIR.joinpath('*'))
VPN_SERVICE = 'openvpn-client@{}.service'.format(VPN_CFG)
VPN_ACTION = '{} {{}} {}'.format(SYSTEMCTL, VPN_SERVICE)

HOSTNAME_FILE_SRC = 'hostname'
HOSTNAME_FILE_DST = '/etc/hostname'
HOSTNAME_INST = '/usr/bin/install -o root -g root -m 644 -T {} {}'.format(
    HOSTNAME_FILE_SRC, HOSTNAME_FILE_DST)
HOSTNAME_RESET = '/usr/bin/rm -f {}'.format(HOSTNAME_FILE_DST)

DIGSIG_DATA_DIR = Path('/usr/share/digsig')
DIGSIG_DATA_CLEAN = '/usr/bin/rm -Rf {}'.format(DIGSIG_DATA_DIR.joinpath('*'))

UNCONFIGURED_SERVICE = '{} {{}} unconfigured-warning.service'.format(SYSTEMCTL)
APPLICATION_SERVICE = '{} {{}} application.service'.format(SYSTEMCTL)

RESET_OPS = (
    ('reset hostname', HOSTNAME_RESET),
    ('remove digital signage data', DIGSIG_DATA_CLEAN),
    ('disable OpenVPN service', VPN_ACTION.format('disable')),
    ('Removing OpenVPN configuration', VPN_CLEAN),
    ('disable application', APPLICATION_SERVICE.format('disable')),
    ('enable on-screen warning', UNCONFIGURED_SERVICE.format('enable')))


class ProgramError(Exception):
    """Indicates an error in the program."""

    def __init__(self, error, *messages, exit_code=2):
        """Prints error messages to stderr and exit."""
        super().__init__(error, *messages)
        self.error = error
        self.messages = messages
        self.exit_code = exit_code

    def __str__(self):
        """Returns the respective string."""
        return f'\033[91m\033[1m{self.error}\033[0m {self.message}'

    @property
    def message(self):
        """Returns the respective message text."""
        return ' '.join(str(message) for message in self.messages)


class InvalidCredentials(Exception):
    """Indicates invalid credentials."""

    pass


class Unauthorized(Exception):
    """Indicates that the user is not allowed
    to setup the respective terminal.
    """

    pass


class APIError(Exception):
    """Indicates an error while using the web API."""

    def __init__(self, message):
        """Sets the text."""
        super().__init__()
        self.message = message

    def __str__(self):
        """Returns the message."""
        return self.message


class ValueMismatch(Exception):
    """Indicates that a pair of values does not match."""

    pass


def ask(question, default=False, yes=('y', 'yes')):
    """Ask a question and return True on yes or else False."""

    suffix = ' [Y/n]: ' if default else ' [y/N]: '

    try:
        reply = input(question + suffix)
    except (EOFError, KeyboardInterrupt):
        print()
        return False

    if not reply:
        return default

    return reply.lower() in yes


def confirm_terminal(terminal_information, serial_number=None, verbose=False):
    """Prompt the user to confirm the given location."""

    terminal_information = list(order_terminal_information(
        terminal_information))

    # Update serial number hint to indicate changed serial number.
    if serial_number is not None:
        for index, (key, value) in enumerate(terminal_information):
            if key == 'Serial number':
                if value is None:
                    value = serial_number
                else:
                    value = ' → '.join((str(value), serial_number))

                terminal_information[index] = (key, value)

    print(BOLD.format('You are about to configure the following terminal:'))
    print()
    print(make_table(terminal_information))
    print()

    if ask('Is this correct?'):
        if verbose:
            print('Retrieving OpenVPN data.')
        else:
            print('Please wait...')
    else:
        raise ProgramError('Setup aborted by user.')


def read_serial_number():
    """Reads the serial number."""

    print('Enter serial number of the device.')
    print('Press [Ctrl]+[D] to skip this step.')
    serial_number = input('Serial number: ')
    serial_number = serial_number.strip()

    try:
        serial_number_confirmation = input('Confirm serial number: ')
    except EOFError:
        print()
        serial_number_confirmation = None
    else:
        serial_number_confirmation = serial_number_confirmation.strip()

    if serial_number and serial_number_confirmation:
        if serial_number == serial_number_confirmation:
            return serial_number

        raise ValueMismatch()

    return None


def strpdatetime(string):
    """Parses the datetime from a string."""

    if string is not None:
        for datetime_format in DATETIME_FORMATS:
            with suppress(ValueError):
                return datetime.strptime(string, datetime_format)

    return None


def make_table_rows(key_value_pairs, header=True, spacing=' {} '):
    """Generates a UTF-8 table."""

    items = []
    keys_len = 0
    value_len = 0

    for key, value in key_value_pairs:
        key = spacing.format(key)
        value = spacing.format(value)
        keys_len = max(keys_len, len(key))
        value_len = max(value_len, len(value))
        items.append((key, value))

    yield Table.HEADER.value.format(
        Table.BOLD.value * keys_len, Table.BOLD.value * value_len)

    for row, (key, value) in enumerate(items, start=1):
        key = key.ljust(keys_len)
        value = value.ljust(value_len)

        if header and row == 1:
            yield Table.ROW.value.format(BOLD.format(key), BOLD.format(value))
            yield Table.BOLD_LINE.value.format(
                Table.BOLD.value * keys_len,
                Table.BOLD.value * value_len)
        else:
            yield Table.ROW.value.format(key, value)

            if row < len(items):
                yield Table.THIN_LINE.value.format(
                    Table.THIN.value * keys_len,
                    Table.THIN.value * value_len)
            else:
                yield Table.FOOTER.value.format(
                    Table.BOLD.value * keys_len,
                    Table.BOLD.value * value_len)


def make_table(key_value_pairs, header=True, spacing=' {} '):
    """Generates a UTF-8 table."""

    return '\n'.join(make_table_rows(
        key_value_pairs, header=header, spacing=spacing))


def order_terminal_information(dictionary):
    """Orders the terminal information."""

    yield ('Option', 'Value')   # Header
    yield ('TID', dictionary['tid'])

    try:
        customer_id = dictionary['customer']['id']
        customer_name = dictionary['customer']['name']
    except KeyError:
        yield ('Customer', dictionary['customer'])
    else:
        yield ('Customer', '{} ({})'.format(customer_id, customer_name))

    try:
        location = dictionary['location']
    except KeyError:
        yield ('Location', '!!!Not configured!!!')
    else:
        address = location['address']

        with suppress(KeyError):
            yield ('Street', address['street'])

        with suppress(KeyError):
            yield ('House number', address['house_number'])

        with suppress(KeyError):
            yield ('ZIP code', address['zip_code'])

        with suppress(KeyError):
            yield ('City', address['city'])

        with suppress(KeyError):
            yield ('Annotation', location['annotation'])

    yield ('Scheduled', dictionary.get('scheduled', 'Not scheduled.'))
    yield ('Deployed', dictionary.get('deployed', 'Not deployed.'))
    yield ('Serial number', dictionary.get('serial_number'))


def system(cmd, verbose=False):
    """Invoke system commands."""

    output = None if verbose else DEVNULL
    completed_process = run(
        cmd, shell=True, stdin=DEVNULL, stdout=output, stderr=output)
    completed_process.check_returncode()
    return completed_process


def configure(tid, cid, vpndata, verbose=False):
    """Performs the terminal configuration."""

    with Configurator(tid, cid, vpndata) as configurator:
        if verbose:
            print('Installing OpenVPN configuration.')

        with ErrorHandler('Installation of OpenVPN configuration failed.'):
            configurator.configure_openvpn()

        if verbose:
            print('Enabling OpenVPN.')

        with ErrorHandler('Enabling of OpenVPN client failed.'):
            configurator.enable_vpn()

        if verbose:
            print('Restarting OpenVPN.')

        with ErrorHandler('Restart of OpenVPN client failed.'):
            configurator.restart_vpn()

        if verbose:
            print('Waiting for OpenVPN server to start.')

        sleep(VPN_GRACETIME)

        if verbose:
            print('Checking OpenVPN connection.')

        with ErrorHandler('Cannot contact OpenVPN server.'):
            configurator.test_vpn()

        if verbose:
            print('Installing {}.'.format(HOSTNAME_FILE_DST))

        with ErrorHandler('Installation of', HOSTNAME_FILE_DST, 'failed.'):
            configurator.configure_hostname()

        if verbose:
            print('Disabling on-screen warning.')

        with ErrorHandler('Disabling of on-screen warning failed.'):
            configurator.disable_warning()

        print()
        print('Setup completed successfully.')

        if ask('Do you want to reboot now?'):
            system('/usr/bin/reboot')
        else:
            print('Okay, not rebooting.',
                  'You can reboot any time by pressing',
                  '[CTRL]+[ALT]+[DEL]', sep='\n')


def reset(verbose=False):
    """Resets the system's configuration."""

    for operation, cmd in RESET_OPS:
        try:
            system(cmd, verbose=verbose)
        except CalledProcessError:
            raise ProgramError('Could not {}.'.format(operation))


def hidslcfg(options):
    """HOMEINFO Digital Signage Linux configurator.

    Maintainer: Richard Neumann <r.neumann@homeinfo.de>

    Usage:
        hidslcfg <ident> [options]
        hidslcfg [--tid=<terminal_id>] [--cid=<customer_id>] [options]

    Options:
        --tid=<terminal_id>     Specifies the physical terminal identifier.
        --cid=<customer_id>     Specifies the customer identifier.
        --user=<user_name>      Specifies the setup user's name.
        --no-serial-number      Do not prompt to set system's serial number.
        --verbose               Be gassy.
        -h --help               Show this page.
    """
    verbose = options['--verbose']
    ident = options['<ident>']

    if ident is None:
        tid = options['--tid']
        cid = options['--cid']
    else:
        try:
            tid, cid = ident.split('.')
        except ValueError:
            raise ProgramError(
                'INVALID IDENT', 'Identifier must be like <tid>.<cid>')

    user = options['--user']
    query_serial_number = not options['--no-serial-number']

    try:
        if cid is None:
            cid = input('Customer ID: ')
        if tid is None:
            tid = input('Terminal ID: ')
        if user is None:
            user = input('User name: ')

        passwd = getpass('Password: ')
    except KeyboardInterrupt:
        print()
        raise ProgramError('Configuration aborted by user.')

    serial_number = None

    if query_serial_number:
        try:
            serial_number = read_serial_number()
        except KeyboardInterrupt:
            print()
            raise ProgramError('Setup aborted by user.')
        except EOFError:
            print()
            print('Skipping setting of serial number.')
        except ValueMismatch:
            raise ProgramError('Serial numbers do not match.')

    with APIClient(user, passwd, cid, tid) as api_client:
        confirm_terminal(
            api_client.terminal_information, serial_number=serial_number,
            verbose=verbose)

        if serial_number is not None:
            print('Setting serial number of {}.{} to "{}".'.format(
                tid, cid, serial_number))
            api_client.set_serial_number(serial_number)

        configure(tid, cid, api_client.vpndata, verbose=verbose)

    return 0


def hidslreset(options):
    """HOMEINFO Digital Signage Linux resetter.

    Maintainer: Richard Neumann <r.neumann@homeinfo.de>

    Usage:
        hidslreset [options]

    Options:
        --verbose               Be gassy.
        -h --help               Show this page.
    """
    verbose = options['--verbose']

    try:
        reset(verbose=verbose)
    except KeyboardInterrupt:
        print()
        raise ProgramError('Reset aborted by user.')

    return 0


def main():
    """Runs the main program."""

    if geteuid() != 0:
        raise ProgramError('You need to be root to run this script!')

    script_name = Path(__file__).name

    if script_name == 'hidslcfg':
        return hidslcfg(docopt(hidslcfg.__doc__))
    elif script_name == 'hidslreset':
        return hidslreset(docopt(hidslreset.__doc__))
    else:
        raise ProgramError('Script name "{}" is invalid.'.format(script_name))


class Table(Enum):
    """Table elements."""

    THIN = '─'
    BOLD = '═'
    HEADER = '╔{}╦{}╗'
    BOLD_LINE = '╠{}╬{}╣'
    ROW = '║{}║{}║'
    THIN_LINE = '╟{}╫{}╢'
    FOOTER = '╚{}╩{}╝'


class APIClient:
    """Class to retrieve data from the web API."""

    PROTO = 'https'
    HOST = 'termgr.homeinfo.de'
    PATH = '/setup'

    def __init__(self, user, passwd, cid, tid):
        """Initialize with credentials."""
        self.user = user
        self.passwd = passwd
        self.cid = cid
        self.tid = tid

    def __enter__(self):
        return self

    def __exit__(self, typ, value, traceback):
        """Handles possible errors."""
        if isinstance(value, InvalidCredentials):
            raise ProgramError(
                'INVALID CREDENTIALS',
                'Your user name and / or password are incorrect.')
        elif isinstance(value, Unauthorized):
            raise ProgramError(
                'UNAUTHORIZED',
                'You are not authorized to set up this terminal.')
        elif isinstance(value, APIError):
            raise ProgramError('WEB API ERROR', value)
        elif isinstance(value, KeyboardInterrupt):
            print()
            raise ProgramError('Setup aborted by user.')

    def __call__(self, action, **kwargs):
        """POST to the API with the respective
        user name, password and action call.
        """
        post_data = self.post_data
        post_data.update(kwargs)
        post_data = dumps(post_data).encode()

        try:
            reply = requests.post(self.get_url(action), data=post_data)
        except requests.ConnectionError:
            raise ProgramError(
                'CONNECTION ERROR', 'Check your internet connection.')

        if reply.status_code == 200:
            return reply
        elif reply.status_code == 401:
            if reply.text == 'Invalid credentials':
                raise InvalidCredentials()

            raise Unauthorized()

        raise APIError(reply.text)

    @property
    def post_data(self):
        """Returns the HTTP parameters dictionary."""
        return {
            'user_name': self.user,
            'passwd': self.passwd,
            'cid': self.cid,
            'tid': self.tid}

    @property
    def terminal_information(self):
        """Returns the terminal location."""
        return loads(self('terminal_information').text)

    @property
    def vpndata(self):
        """Returns the terminal's VPN keys and configuration."""
        return self('vpn_data').content

    def get_url(self, action):
        """Returns the API URL."""
        return '{}://{}{}/{}'.format(self.PROTO, self.HOST, self.PATH, action)

    def set_serial_number(self, serial_number):
        """Sets the respective serial number."""
        return self('serial_number', serial_number=serial_number)


class ErrorHandler:
    """Handles subprocess errors."""

    def __init__(self, *messages):
        """Sets the respective error messages."""
        self.messages = messages

    def __enter__(self):
        return self

    def __exit__(self, _, exception, __):
        """Handles called process error."""
        if isinstance(exception, CalledProcessError):
            raise ProgramError('SUBPROCESS ERROR', *self.messages, exit_code=3)


class Configurator(TemporaryDirectory):
    """Terminal configurator."""

    def __init__(self, tid, cid, vpndata, verbose=False):
        """Sets VPN configuration."""
        super().__init__()
        self.tid = tid
        self.cid = cid
        self.vpndata = vpndata
        self.verbose = verbose
        self.origin = None

    def __enter__(self):
        """Writes the VPN data to the respective temporary directory."""
        super().__enter__()
        self.origin = getcwd()
        chdir(self.name)
        self._init_vpn_data()
        self._init_hostname()
        return self

    def __exit__(self, typ, value, traceback):
        """Navigates back to original folder
        and removes the temporary directory.
        """
        chdir(self.origin)
        return super().__exit__(typ, value, traceback)

    def _init_vpn_data(self):
        """Initializes the VPN data file."""
        vpndata_path = Path(self.name).joinpath(VPN_ARCHIVE)

        with vpndata_path.open('wb') as vpndata_file:
            vpndata_file.write(self.vpndata)

    def _init_hostname(self):
        """Initializes the host name file."""
        hostname = '{tid}.{cid}'.format(tid=self.tid, cid=self.cid)

        with open(HOSTNAME_FILE_SRC, 'w') as hostname_tmp:
            hostname_tmp.write(hostname)

    def configure_openvpn(self):
        """Installs the OpenVPN configuration."""
        return system(VPN_INST, verbose=self.verbose)

    def enable_vpn(self):
        """Enables the OpenVPN service."""
        return system(VPN_ACTION.format('enable'), verbose=self.verbose)

    def restart_vpn(self):
        """Restarts the OpenVPN service."""
        return system(VPN_ACTION.format('restart'), verbose=self.verbose)

    def test_vpn(self):
        """Tests the OpenVPN connection to the OpenVPN server."""
        return system(PING_HOST.format(VPN_SERVER), verbose=self.verbose)

    def configure_hostname(self):
        """Configures the system's hostname."""
        return system(HOSTNAME_INST, verbose=self.verbose)

    def disable_warning(self):
        """Disables the on-screen unconfigured warning."""
        system(UNCONFIGURED_SERVICE.format('disable'), verbose=self.verbose)


if __name__ == '__main__':
    try:
        exit_(main())
    except ProgramError as program_error:
        print(program_error, file=stderr, flush=True)
        exit_(program_error.exit_code)
