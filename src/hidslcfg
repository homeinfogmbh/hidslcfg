#! /usr/bin/env python3
"""Configure or reset a HIDSL device."""

from contextlib import suppress
from datetime import datetime
from enum import Enum
from getpass import getpass
from json import loads
from os import chdir, geteuid
from pathlib import Path
from subprocess import DEVNULL, CalledProcessError, run
from sys import stderr, exit as exit_
from tempfile import TemporaryDirectory
from time import sleep

from requests import ConnectionError as RequestsConnectionError, get, post


__all__ = [
    'InvalidCredentials',
    'Unauthorized',
    'APIError',
    'fail',
    'APIClient',
    'Configurator']

DATETIME_FORMATS = ('%Y-%m-%dT%H:%M:%S', '%Y-%m-%dT%H:%M:%S.%f')
BOLD = '\033[1m{}\033[0m'

SYSTEMCTL = '/usr/bin/systemctl'
PING_HOST = '/usr/bin/ping -W 1 -c 5 {}'

VPN_CLIENT_DIR = Path('/etc/openvpn/client')
VPN_ARCHIVE = 'openvpn.tar.gz'
VPN_CFG = 'terminals'
VPN_SERVER = '10.8.0.1'
VPN_GRACETIME = 3
VPN_INST = '/usr/bin/tar xf {archive} -C {client_dir}'.format(
    archive=VPN_ARCHIVE, client_dir=VPN_CLIENT_DIR)
VPN_CLEAN = '/usr/bin/rm -f {}'.format(VPN_CLIENT_DIR.joinpath('*'))
VPN_SERVICE = 'openvpn-client@{}.service'.format(VPN_CFG)
VPN_ACTION = '{} {{}} {}'.format(SYSTEMCTL, VPN_SERVICE)

HOSTNAME_FILE_SRC = 'hostname'
HOSTNAME_FILE_DST = '/etc/hostname'
HOSTNAME_INST = '/usr/bin/install -o root -g root -m 644 -T {} {}'.format(
    HOSTNAME_FILE_SRC, HOSTNAME_FILE_DST)
HOSTNAME_RESET = '/usr/bin/rm -f {}'.format(HOSTNAME_FILE_DST)

DIGSIG_DATA_DIR = Path('/usr/share/digsig')
DIGSIG_DATA_CLEAN = '/usr/bin/rm -Rf {}'.format(DIGSIG_DATA_DIR.joinpath('*'))

UNCONFIGURED_SERVICE = '{} {{}} unconfigured-warning.service'.format(SYSTEMCTL)
APPLICATION_SERVICE = '{} {{}} application.service'.format(SYSTEMCTL)

RESET_OPS = (
    ('reset hostname', HOSTNAME_RESET),
    ('remove digital signage data', DIGSIG_DATA_CLEAN),
    ('disable OpenVPN service', VPN_ACTION.format('disable')),
    ('Removing OpenVPN configuration', VPN_CLEAN),
    ('disable application', APPLICATION_SERVICE.format('disable')),
    ('enable on-screen warning', UNCONFIGURED_SERVICE.format('enable')))


class InvalidCredentials(Exception):
    """Indicates invalid credentials."""

    pass


class Unauthorized(Exception):
    """Indicates that the user is not allowed
    to setup the respective terminal.
    """

    pass


class ErrorMessage(Exception):
    """Generic error message."""

    def __init__(self, msg):
        """Sets the text"""
        super().__init__()
        self._msg = msg

    def __str__(self):
        """Returns the message"""
        return self._msg


class APIError(ErrorMessage):
    """Indicates an error while using the web API."""

    pass


class ValueMismatch(Exception):
    """Indicates that a pair of values does not match."""

    pass


class Table(Enum):
    """Table elements."""

    THIN = '─'
    BOLD = '═'
    HEADER = '╔{}╦{}╗'
    BOLD_LINE = '╠{}╬{}╣'
    ROW = '║{}║{}║'
    THIN_LINE = '╟{}╫{}╢'
    FOOTER = '╚{}╩{}╝'


def fail(err, *msgs, exit_code=3):
    """Prints error messages to stderr and exit."""

    print('\033[91m\033[1m', end='', file=stderr)  # Red and bold.
    print(err, end='', file=stderr)
    print('\033[0m', end=' ', file=stderr)
    print(*msgs, file=stderr)
    exit_(exit_code)


def subproc_fail(*msgs):
    """Prints subprocess error messages to stderr and exit."""

    fail('SUBPROCESS ERROR', *msgs, exit_code=3)


def ask(question, default=False, yes=('y', 'yes')):
    """Ask a question and return True on yes or else False."""

    suffix = ' [Y/n]: ' if default else ' [y/N]: '

    try:
        reply = input(question + suffix)
    except (EOFError, KeyboardInterrupt):
        return False
    else:
        if not reply:
            return default

        return reply.lower() in yes


def confirm_terminal(terminal_information, verbose=False):
    """Prompt the user to confirm the given location."""

    print('You are about to configure the following terminal:')
    print()
    print(make_table(order_terminal_information(terminal_information)))
    print()

    if ask('Is this correct?'):
        if verbose:
            print('Retrieving OpenVPN data.')
        else:
            print('Please wait...')
    else:
        fail('Setup aborted by user.')


def read_serial_number():
    """Reads the serial number."""

    print('Enter serial number of the device.')
    print('Press [Ctrl]+[D] to skip this step.')
    serial_number = input('Serial number: ')
    serial_number = serial_number.strip()

    try:
        serial_number_confirmation = input('Confirm serial number: ')
    except EOFError:
        print()
        serial_number_confirmation = None
    else:
        serial_number_confirmation = serial_number_confirmation.strip()

    if serial_number and serial_number_confirmation:
        if serial_number == serial_number_confirmation:
            return serial_number

        raise ValueMismatch()

    return None


def strpdatetime(string):
    """Parses the datetime from a string."""

    if string is not None:
        for datetime_format in DATETIME_FORMATS:
            with suppress(ValueError):
                return datetime.strptime(string, datetime_format)


def make_table_rows(key_value_pairs, header=True, spacing=' {} '):
    """Generates a UTF-8 table."""

    items = []
    keys_len = 0
    value_len = 0

    for key, value in key_value_pairs:
        key = spacing.format(key)
        value = spacing.format(value)
        keys_len = max(keys_len, len(key))
        value_len = max(value_len, len(value))
        items.append((key, value))

    yield Table.HEADER.value.format(
        Table.BOLD.value * keys_len, Table.BOLD.value * value_len)

    for row, (key, value) in enumerate(items, start=1):
        key = key.ljust(keys_len)
        value = value.ljust(value_len)

        if header and row == 1:
            yield Table.ROW.value.format(BOLD.format(key), BOLD.format(value))
            yield Table.BOLD_LINE.value.format(
                Table.BOLD.value * keys_len,
                Table.BOLD.value * value_len)
        else:
            yield Table.ROW.value.format(key, value)

            if row < len(items):
                yield Table.THIN_LINE.value.format(
                    Table.THIN.value * keys_len,
                    Table.THIN.value * value_len)
            else:
                yield Table.FOOTER.value.format(
                    Table.BOLD.value * keys_len,
                    Table.BOLD.value * value_len)


def make_table(key_value_pairs, header=True, spacing=' {} '):
    """Generates a UTF-8 table."""

    return '\n'.join(make_table_rows(
        key_value_pairs, header=header, spacing=spacing))


def order_terminal_information(dictionary):
    """Orders the terminal information."""

    yield ('Option', 'Value')   # Header
    yield ('TID', dictionary['tid'])

    try:
        customer_id = dictionary['customer']['id']
        customer_name = dictionary['customer']['name']
    except KeyError:
        yield ('Customer', dictionary['customer'])
    else:
        yield ('Customer', '{} ({})'.format(customer_id, customer_name))

    try:
        location = dictionary['location']
    except KeyError:
        yield ('Location', '!!!Not configured!!!')
    else:
        address = location['address']

        with suppress(KeyError):
            yield ('Street', address['street'])

        with suppress(KeyError):
            yield ('House number', address['house_number'])

        with suppress(KeyError):
            yield ('ZIP code', address['zip_code'])

        with suppress(KeyError):
            yield ('City', address['city'])

        with suppress(KeyError):
            yield ('Annotation', location['annotation'])

    yield ('Scheduled', dictionary.get('scheduled', 'Not scheduled.'))
    yield ('Deployed', dictionary.get('deployed', 'Not deployed.'))
    yield ('Serial number', dictionary.get('serial_number'))


def system(cmd, verbose=False):
    """Invoke system commands."""

    output = None if verbose else DEVNULL
    completed_process = run(
        cmd, shell=True, stdin=DEVNULL, stdout=output, stderr=output)
    completed_process.check_returncode()
    return completed_process


def configure(tid, cid, vpndata, verbose=False):
    """Performs the terminal configuration."""

    with Configurator(tid, cid, vpndata) as configurator:
        if verbose:
            print('Installing OpenVPN configuration.')

        try:
            configurator.configure_openvpn()
        except CalledProcessError:
            subproc_fail('Installation of OpenVPN configuration failed.')

        if verbose:
            print('Enabling OpenVPN.')

        try:
            configurator.enable_vpn()
        except CalledProcessError:
            subproc_fail('Enabling of OpenVPN client failed.')

        if verbose:
            print('Restarting OpenVPN.')

        try:
            configurator.restart_vpn()
        except CalledProcessError:
            subproc_fail('Restart of OpenVPN client failed.')

        if verbose:
            print('Waiting for OpenVPN server to start.')

        sleep(VPN_GRACETIME)

        if verbose:
            print('Checking OpenVPN connection.')

        try:
            configurator.test_vpn()
        except CalledProcessError:
            subproc_fail('Cannot contact OpenVPN server.')

        if verbose:
            print('Installing {}.'.format(HOSTNAME_FILE_DST))

        try:
            configurator.configure_hostname()
        except CalledProcessError:
            subproc_fail('Installation of', HOSTNAME_FILE_DST, 'failed.')

        if verbose:
            print('Disabling on-screen warning.')

        try:
            configurator.disable_warning()
        except CalledProcessError:
            subproc_fail('Disabling of on-screen warning failed.')

        print()
        print('Setup completed successfully.')

        if ask('Do you want to reboot now?'):
            system('/usr/bin/reboot')
        else:
            print('Okay, not rebooting.',
                  'You can reboot any time by pressing',
                  '[CTRL]+[ALT]+[DEL]', sep='\n')


def reset(verbose=False):
    """Resets the system's configuration."""

    for operation, cmd in RESET_OPS:
        try:
            system(cmd, verbose=verbose)
        except CalledProcessError:
            fail('Could not {}.'.format(operation))


def hidslcfg(options):
    """HOMEINFO Digital Signage Linux configurator.

    Maintainer: Richard Neumann <r.neumann@homeinfo.de>

    Usage:
        hidslcfg <ident> [options]
        hidslcfg [--tid=<terminal_id>] [--cid=<customer_id>] [options]

    Options:
        --tid=<terminal_id>     Specifies the physical terminal identifier.
        --cid=<customer_id>     Specifies the customer identifier.
        --user=<user_name>      Specifies the setup user's name.
        --no-serial-number      Do not prompt to set system's serial number.
        --verbose               Be gassy.
        -h --help               Show this page.
    """
    verbose = options['--verbose']
    ident = options['<ident>']

    if ident is None:
        tid = options['--tid']
        cid = options['--cid']
    else:
        try:
            tid, cid = ident.split('.')
        except ValueError:
            fail('INVALID IDENT',
                 'Identifier must be like <tid>.<cid>')

    user = options['--user']
    query_serial_number = not options['--no-serial-number']

    try:
        if cid is None:
            cid = input('Customer ID: ')
        if tid is None:
            tid = input('Terminal ID: ')
        if user is None:
            user = input('User name: ')

        passwd = getpass('Password: ')
    except KeyboardInterrupt:
        print()
        fail('Configuration aborted by user.')

    serial_number = None

    if query_serial_number:
        try:
            serial_number = read_serial_number()
        except KeyboardInterrupt:
            print()
            fail('Setup aborted by user.')
        except EOFError:
            print()
            print('Skipping setting of serial number.')
        except ValueMismatch:
            fail('Serial numbers do not match.')

    with APIClient(user, passwd, cid, tid) as api_client:
        confirm_terminal(api_client.terminal_information, verbose=verbose)

        if serial_number is not None:
            print('Setting serial number of {}.{} to "{}".'.format(
                tid, cid, serial_number))
            api_client.set_serial_number(serial_number)

        configure(tid, cid, api_client.vpndata, verbose=verbose)

    exit_(0)


def hidslreset(options):
    """HOMEINFO Digital Signage Linux resetter.

    Maintainer: Richard Neumann <r.neumann@homeinfo.de>

    Usage:
        hidslreset [options]

    Options:
        --verbose               Be gassy.
        -h --help               Show this page.
    """
    verbose = options['--verbose']

    try:
        reset(verbose=verbose)
    except KeyboardInterrupt:
        print()
        fail('Reset aborted by user.')

    exit_(0)


class APIClient:
    """Class to retrieve data from the web API."""

    PROTO = 'https'
    HOST = 'termgr.homeinfo.de'
    PATH = '/setup'

    def __init__(self, user, passwd, cid, tid):
        """Initialize with credentials."""
        self.user = user
        self.passwd = passwd
        self.cid = cid
        self.tid = tid

    def __enter__(self):
        return self

    def __exit__(self, typ, value, traceback):
        if isinstance(value, InvalidCredentials):
            fail('INVALID CREDENTIALS',
                 'Your user name and / or password are incorrect.')
        elif isinstance(value, Unauthorized):
            fail('UNAUTHORIZED',
                 'You are not authorized to set up this terminal.')
        elif isinstance(value, APIError):
            fail('WEB API ERROR', value)
        elif isinstance(value, KeyboardInterrupt):
            print()
            fail('Setup aborted by user.')

    def params(self, action):
        """Returns the HTTP parameters dictionary."""
        return {
            'user_name': self.user,
            'passwd': self.passwd,
            'action': action,
            'cid': self.cid,
            'tid': self.tid}

    @property
    def url(self):
        """Returns the API URL."""
        return '{}://{}{}'.format(self.PROTO, self.HOST, self.PATH)

    @property
    def terminal_information(self):
        """Returns the terminal location."""
        return loads(self.get('terminal_information').text)

    @property
    def vpndata(self):
        """Returns the terminal's VPN keys and configuration."""
        return self.get('vpn_data').content

    def get(self, action):
        """GET from the API with the respective
        user name, password and action call.
        """
        try:
            reply = get(self.url, params=self.params(action))
        except RequestsConnectionError:
            fail('CONNECTION ERROR', 'Check your internet connection.')
        else:
            if reply.status_code == 200:
                return reply
            elif reply.status_code == 401:
                if reply.text == 'Invalid credentials':
                    raise InvalidCredentials()

                raise Unauthorized()

            raise APIError(reply.text)

    def post(self, action, data):
        """POST to the API with the respective
        user name, password and action call.
        """
        try:
            reply = post(self.url, data=data, params=self.params(action))
        except RequestsConnectionError:
            fail('CONNECTION ERROR', 'Check your internet connection.')
        else:
            if reply.status_code == 200:
                return reply
            elif reply.status_code == 401:
                if reply.text == 'Invalid credentials':
                    raise InvalidCredentials()

                raise Unauthorized()

            raise APIError(reply.text)

    def set_serial_number(self, serial_number):
        """Sets the respective serial number."""
        return self.post('serial_number', serial_number.encode())


class Configurator(TemporaryDirectory):
    """Terminal configurator."""

    def __init__(self, tid, cid, vpndata, verbose=False):
        """Sets VPN configuration."""
        super().__init__()
        self.tid = tid
        self.cid = cid
        self.vpndata = vpndata
        self.verbose = verbose

    def __enter__(self):
        """Writes the VPN data to the respective temporary directory."""
        super().__enter__()
        vpndata_path = Path(self.name).joinpath(VPN_ARCHIVE)

        with vpndata_path.open('wb') as vpndata_file:
            vpndata_file.write(self.vpndata)

        return self

    def configure_openvpn(self):
        """Installs the OpenVPN configuration."""
        chdir(self.name)
        system(VPN_INST, verbose=self.verbose)

    def enable_vpn(self):
        """Enables the OpenVPN service."""
        system(VPN_ACTION.format('enable'), verbose=self.verbose)

    def restart_vpn(self):
        """Restarts the OpenVPN service."""
        system(VPN_ACTION.format('restart'), verbose=self.verbose)

    def test_vpn(self):
        """Tests the OpenVPN connection to the OpenVPN server."""
        system(PING_HOST.format(VPN_SERVER), verbose=self.verbose)

    def configure_hostname(self):
        """Configures the system's hostname."""
        chdir(self.name)
        hostname = '{tid}.{cid}'.format(tid=self.tid, cid=self.cid)

        with open(HOSTNAME_FILE_SRC, 'w') as hostname_tmp:
            hostname_tmp.write(hostname)

        system(HOSTNAME_INST, verbose=self.verbose)

    def disable_warning(self):
        """Disables the on-screen unconfigured warning."""
        system(UNCONFIGURED_SERVICE.format('disable'), verbose=self.verbose)


if __name__ == '__main__':
    try:
        from docopt import docopt
    except ImportError:
        fail('"docopt" not available', 'CLI mode not available.', exit_code=4)
    else:
        if geteuid() != 0:
            fail('You need to be root to run this script!')
        else:
            SCRIPT_NAME = Path(__file__).name

            if SCRIPT_NAME == 'hidslcfg':
                hidslcfg(docopt(hidslcfg.__doc__))
            elif SCRIPT_NAME == 'hidslreset':
                hidslreset(docopt(hidslreset.__doc__))
            else:
                fail('Script name "{}" is invalid.'.format(SCRIPT_NAME))
