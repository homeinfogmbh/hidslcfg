#! /usr/bin/env python3
"""HOMEINFO Digital Signage Linux image manager

Usage:
    hidslimg backup <partition> <image> [--compression=<x>]
    hidslimg restore <image> <device> [--efi [--size=<size>] [--i386]] \
[--rootfs=<fs>]

Options:
    --compression=<x>  Compress tar archive using <x>
    --efi              Restore for (U)EFI boot
    --size=<size>      Create EFI partition of specified size [default: +100M]
    --i386             When restoring for (U)EFI boot, use a 32 bit EFI loader
    --rootfs=<fs>      Specifies the root file system to be used \
[default: ext4]
    -h --help          Show this page.
    -v --version       Show version.
"""

from sys import stderr
from os import listdir, makedirs
from os.path import join, basename
from tempfile import TemporaryFile, mkdtemp
from subprocess import run
from itertools import chain

import tarfile

from docopt import docopt
from contextlib import ExitStack


__all__ = ['PartType', 'Partition', 'Partitioner', 'Chroot']


# Generic base packages
PACKAGES = ['base', 'openvpn', 'openssh', 'ufw', 'ntp', 'sudo', 'vim']


class PartitioningError(Exception):
    """Indicated an error during partitioning"""
    pass


class FormattingError(Exception):
    """Indicated an error during file system creation"""
    pass


def fail(err, *msgs, exit_code=3):
    """Print message to stderr and exit"""
    print('\033[91m\033[1m', end='', file=stderr)  # Red and bold
    print(err, end='', file=stderr)
    print('\033[0m', end=' ', file=stderr)
    print(*msgs, file=stderr)
    exit(exit_code)


def mkparts(device, efi=False):
    """Create partitions"""
    with Fdisk(device) as fdisk:
        if efi:
            fdisk.new('g')
            fdisk.add(end='+100M')
            fdisk.chtyp('ef')
            fdisk.add()
        else:
            fdisk.new()

            fdisk.add()


def mkfs(device, efi=False, rootfs='ext4'):
    """Create file systems"""
    if efi:
        Mkfs(device[1])('fat32', label='EFI')
        Mkfs(device[2])(rootfs, label='root')
    else:
        Mkfs(device[1])(rootfs, label='root')


def pacstrap(device, packages=None):
    """Install base system with packages"""
    PACSTRAP = '/usr/bin/pacstrap {mountpoint} {packages}'
    if packages is None:
        packages = []
    # Chain base packages and additional packages
    packages = [p for p in chain(PACKAGES, packages)]
    with ExitStack() as es:
        if efi:
            root_mount = MountPoint(device[2])
            es.enter_context(root_mount)
            boot_dir = join(root_mount.mountpoint, 'boot')
            efi_dir = join(boot_dir, 'EFI')
            makedirs(efi_dir, mode=0o755, exist_ok=True)
            efi_mount = MountPoint(efi_dir)
            es.enter_context(efi_mount)
        else:
            root_mount = MountPoint(device[2])
            boot_dir = join(root_mount.mountpoint, 'boot')
            makedirs(boot_dir, mode=0o755, exist_ok=True)
        cmd = PACSTRAP.format(
            mountpoint=root_mount.mountpoint,
            packages=' '.join(packages))
        return run(cmd).returncode == 0


def restore(image, rootpartpath, efi=False, efi32=False):
    """Restore the image"""
    with Partition(rootpartpath) as rootpart:
        rootpart.restore(image)
        if efi:
            esp = '/boot/efi'
            esppath = join(rootpart.mountpoint, esp)
            makedirs(esp, mode=0o755, exist_ok=True)
            efipart = Partition(efipartpath)
            efipart.mount(esppath)
        chroot = Chroot(rootpart.mountpoint)
        if efi:
            chroot.mkboot(efi=True, efi32=efi32, esp=esp)
            efipart.umount()
        else:
            chroot.mkboot(bootdev=rootpartpath, efi, efi32, esp)


class PartType():
    """Partition types"""

    EFI = 'C12A7328-F81F-11D2-BA4B-00A0C93EC93B'
    LINUX = '0FC63DAF-8483-4772-8E79-3D69D8477DE4'


class UnixDevice():
    """Represents a UNIX device"""

    def __init__(self, path):
        self._path = path

    def __str__(self):
        return self._path


class Disk(UnixDevice):
    """Represents a disk"""

    def __index__(self, i):
        dev = basename(self._path)
        if dev.startswith('mmcblk'):
            partname = '{0}p{1}'.format(self._path, i)
        else:
            partname = '{0}{1}'.format(self._path, i)
        return Partition(partname)


class Partition(UnixDevice):
    """Represents a partition"""
    pass


class Fdisk():
    """Fdisk wrapper"""

    def __init__(self, disk, newtyp=None, partitions=None, types=None):
        """Initializes the fdisk wrapper"""
        self._disk = disk
        self._commands = []
        if newtyp is not None:
            self.new(typ=newtyp)
        if partitions is not None:
            for partition in partitions:
                self.add(*partition)
        if types is not None:
            for typ in types:
                self.chtyp(*typ)
        self._partitions = partitions
        self._types = types

    def __enter__(self):
        return self

    def __exit__(self, *_):
        if not self.commit():
            raise PartitioningError()

    def new(self, typ=None):
        """Creates a new partition table"""
        if typ is not None:
            self._commands.append(typ)
        else:
            self._commands.append('o')

    def add(self, typ=None, partno=None, start=None, end=None):
        """Adds a new partition"""
        typ = '' if typ is None else typ
        partno = '' if partno is None else str(partno)
        start = '' if start is None else str(start)
        end = '' if end is None else str(end)
        self._commands += ['n', typ, partno, start, end]

    def chtyp(self, typ, partno=None):
        """Changes the type of a partition"""
        self._commands.append('t')
        if partno is not None:
            self._commands.append(str(partno))
        self._commands.append(str(typ))

    def write(self):
        """Adds a write statement to the commands list"""
        self._commands.append('w')

    def reset(self):
        """Resets all commands"""
        commands, self._commands = self._commands, []
        return commands

    def commit(self):
        """Actually calls fdisk"""
        commands = self.reset()
        if commands:
            if 'w' not in commands:
                return False
            else:
                input_line = '\n'.join(chain(commands, ['']))
                command_line = ('/usr/bin/echo -e "{input_line}" | '
                                '/usr/bin/fdisk {disk}').format(
                    input_line=input_line, disk=self._disk)
                print(command_line)
                cp = run(command_line, shell=True)
                return cp.returncode == 0
        else:
            return False


class Mkfs():
    """Creates a file system on a partition"""

    CMD = '/usr/bin/mkfs.{0}'

    def __init__(self, partition):
        """Sets the partition"""
        self._partition = partition

    def __call__(self, fs, label=None):
        """Performs the formatting"""
        if fs == 'ext4':
            cmd = 'ext4'
            if label is not None:
                cmd += ' -L {0}'.format(label)
            cmd += ' {0}'.format(self._partition)
        elif fs == 'fat32':
            cmd = 'vfat -F32'
            if label is not None:
                cmd += ' -n {0}'.format(label)
            cmd += ' {0}'.format(self._partition)
        else:
            raise NotImplementedError(
                'Unsupported file system {0}'.format(fs))
        cmd = self.CMD.format(cmd)
        cp = run(cmd, shell=True)
        return cp.returncode == 0


class TerminalInstaller():
    """Installs ArchLinux and HIDSL on a system"""

    def __init__(self, disk, uefi=False):
        """Sets the installation configuration"""
        self._disk = disk
        self._uefi = uefi

    def __enter__(self):
        return self

    def __exit__(self, *_):
        pass

    def __call__(self):
        """Installs the system"""
        try:
            self._partition()
        except PartitioningError:
            print('Partitioning failed')
        else:
            if self._uefi:
                uefi_mkfs = Mkfs(self._disk[1])
                try:
                    uefi_mkfs('fat32', label='UEFI')
                except FormattingError:
                    # TODO: handle
                    pass
                else:
                    root_mkfs = Mkfs(self._disk[2])
                    try:
                        root_mkfs('ext4', label='root')
                    except FormattingError:
                        # TODO: handle
                        pass
                    else:
                        # TODO: IMplement
                        pass

    def _partition(self):
        """Partitions the disk"""
        with Fdisk(self._disk) as fdisk:
            if self._uefi:
                fdisk.new('g')
                fdisk.add(end='+100M')
                fdisk.chtyp('ef')
                fdisk.add()
            else:
                fdisk.new()

                fdisk.add()
            fdisk.write()


class MountPoint():
    """A Linux file system mount point"""

    _MOUNT = '/usr/bin/mount'
    _UMOUNT = '/usr/bin/umount'
    _MKFS = '/usr/bin/mkfs'

    _WRITE_MODES = {
        None: 'w',
        'gz': 'w:gz',
        'bz2': 'w:bz2',
        'xz': 'w:xz'
    }

    def __init__(self, partition, mountpoint=None):
        """Sets the path to the partition device file"""
        self._partition = partition
        self._mountpoint = mountpoint
        self._mounted = False

    def __enter__(self):
        """Enters a with statement"""
        if not self._mounted:
            if self._mountpoint is None:
                self._mountpoint = mkdtemp()
            self._mounted = self.mount()
        return self

    def __exit__(self, *_):
        """Exits a with statement"""
        self._mounted = not self.umount()

    @property
    def path(self):
        """Returns the mount point's path"""
        return self._path

    @property
    def mountpoint(self):
        """Returns the mount point"""
        return self._mountpoint

    def _addfiles(self, tar):
        """Add files to the specified tar archive"""
        for inode in listdir(self._mountpoint):
            path = join(self.path, inode)
            tar.add(path, arcname=inode)

    def mount(self):
        """Mounts the partition"""
        cmd = '{mount} {part} {mountpoint}'.format(
            mount=self._MOUNT, part=self._partition,
            mountpoint=self._mountpoint)
        return run(cmd, shell=True).exitcode == 0

    def umount(self):
        """Un-mounts the partition"""
        if self._mountpoint is None:
            cmd = '{umount} {part}'.format(
                umount=self._UMOUNT, part=self._partition)
            return run(cmd, shell=True).exitcode == 0
        else:
            cmd = '{umount} {mountpoint}'.format(
                umount=self._UMOUNT, mountpoint=self._mountpoint)
            self._mountpoint = None
            return run(cmd, shell=True).exitcode == 0

    def backup(self, name=None, compression=None, autosuffix=True):
        """Backup the mount point into a tar archive of
        the given file name with the given compression.
        If name is None, return bytes of the archive.
        """
        try:
            mode = self._WRITE_MODES[compression]
        except KeyError:
            msg = 'Compression must be one of'
            comps = [comp for comp in self._WRITE_MODES]
            msg = '{msg}: {comps}'.format(msg=msg, comps=comps)
            raise ValueError(msg) from None
        else:
            if name is None:
                with TemporaryFile(mode='w+b') as tmp:
                    with tarfile.open(mode=mode, fileobj=tmp) as tar:
                        self._addfiles(tar)
                    tmp.seek(0)
                    return tmp.read()
            else:
                if autosuffix:
                    tar_suffix = '.tar'
                    if compression is not None:
                        comp_suffix = '.{0}'.format(compression)
                    else:
                        comp_suffix = ''
                    if comp_suffix:
                        suffix = '{0}{1}'.format(tar_suffix, comp_suffix)
                    else:
                        suffix = tar_suffix
                    if not name.endswith(suffix):
                        if not name.endswith(tar_suffix):
                            name += suffix
                        else:
                            name += comp_suffix
                with tarfile.open(name=name, mode=mode) as tar:
                    self._addfiles(tar)

    def restore(self, img):
        """Restores a backup image"""
        with tarfile.open(name=img, mode='r:*') as tar:
            tar.extractall(path=self.mountpoint)


class Chroot():
    """Chroot manager"""

    _CHROOT = '/usr/bin/arch-chroot'
    _GRUB_INSTALL = '/usr/bin/grub-install'
    _GRUB_MKCONFIG = '/usr/bin/grub-mkconfig'

    def __init__(self, root):
        """Sets the chroot root"""
        self._root = root

    @property
    def root(self):
        """Returns the chroot root"""
        return self._root

    def _exec(self, cmd, *args):
        """Execute commands inside the chroot jail"""
        cmd_args = ' '.join(chain([cmd], args))
        cmd = '{chroot} {cmd_args}'.format(
            chroot=self._CHROOT, cmd_args=cmd_args)
        return run(cmd).returncode == 0

    def mkboot(self, bootdev=None, efi=False, efi32=False, esp=None):
        """Installs the bootloader"""
        cmd = self._GRUB_INSTALL
        recheck = '--recheck'
        if efi or efi32:
            self._exec('/usr/bin/modprobe', 'efivarfs')
            if efi32:
                target = '--target=i386-efi'
            else:
                target = '--target=x86_64-efi'
            efi_dir = '--efi-directory={0}'.format(esp)
            ident = '--bootloader-id=grub'
            args = [target, efi_dir, ident, recheck]
        else:
            args = ['--target=i386-pc', recheck, bootdev]
        if self._exec(cmd, *args):
            cmd = self._GRUB_MKCONFIG
            args = ['-o', '/boot/grub/grub.cfg']
            self._exec(cmd, *args)


if __name__ == '__main__':
    options = docopt(__doc__)
    backup = options['backup']
    restore = options['restore']
    image = options['<image>']
    if backup:
        partition = options['<partition>']
        compression = options['--compression']
        with Partition(partition) as part:
            part.backup(name=image, compression=compression)
    elif restore:
        device = options['<device>']
        efi = options['--efi']
        efi32 = options['--i386']
        rootfs = options['--rootfs']
        # Partition disk
        mkparts(device, efi=efi)
        # Set partition paths
        efipartno = 1 if efi else None
        rootpartno = 2 if efi else 1
        # Compensate for mmcblkXpY naming scheme
        if basename(device).startswith('mmcblk'):
            pattern = '{0}p{1}'
        else:
            pattern = '{0}{1}'
        if efi:
            efipartpath = pattern.format(device, efipartno)
        rootpartpath = pattern.format(device, rootpartno)
        # Format partitions
        mkfs(rootpartpath, rootfs, efipartpath=efipartpath)
        # Restore image
        restore(image, rootpartpath, efi=efi, efi32=efi32)
