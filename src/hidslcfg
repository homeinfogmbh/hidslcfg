#! /usr/bin/env python3
"""Configure or reset a HIDSL device"""

from sys import stderr
from os import chdir, geteuid
from os.path import join, basename
from getpass import getpass
from shutil import rmtree
from tempfile import mkdtemp
from subprocess import CalledProcessError, DEVNULL, run
from contextlib import suppress
from time import sleep
from json import loads

from requests import get
from requests.exceptions import ConnectionError


__all__ = [
    'InvalidCredentials',
    'Unauthorized',
    'APIError',
    'OutOfContext',
    'fail',
    'TerminalAddress',
    'APIClient',
    'Configurator']

SYSTEMCTL = '/usr/bin/systemctl'
PING_HOST = '/usr/bin/ping -W 1 -c 5 {}'

VPN_CLIENT_DIR = '/etc/openvpn/client'
VPN_ARCHIVE = 'openvpn.tar.gz'
VPN_CFG = 'terminals'
VPN_SERVER = '10.8.0.1'
VPN_GRACETIME = 3
VPN_INST = '/usr/bin/tar xf {archive} -C {client_dir}'.format(
    archive=VPN_ARCHIVE, client_dir=VPN_CLIENT_DIR)
VPN_CLEAN = "/usr/bin/bash -c '/usr/bin/rm -f {}'".format(
    join(VPN_CLIENT_DIR, '*'))
VPN_SERVICE = 'openvpn-client@{}.service'.format(VPN_CFG)
VPN_ACTION = '{} {{}} {}'.format(SYSTEMCTL, VPN_SERVICE)

HOSTNAME_FILE_SRC = 'hostname'
HOSTNAME_FILE_DST = '/etc/hostname'
HOSTNAME_INST = '/usr/bin/install -o root -g root -m 644 -T {} {}'.format(
    HOSTNAME_FILE_SRC, HOSTNAME_FILE_DST)
HOSTNAME_RESET = '/usr/bin/rm -f {}'.format(HOSTNAME_FILE_DST)

DIGSIG_DATA_DIR = '/usr/share/digsig'
DIGSIG_DATA_CLEAN = '/usr/bin/rm -Rf {}'.format(join(DIGSIG_DATA_DIR, '*'))

UNCONFIGURED_SERVICE = '{} {{}} unconfigured-warning.service'.format(SYSTEMCTL)
APPLICATION_SERVICE = '{} {{}} application.service'.format(SYSTEMCTL)


class InvalidCredentials(Exception):
    """Indicates invalid credentials"""

    pass


class Unauthorized(Exception):
    """Indicates that the user is not allowed
    to setup the respective terminal
    """

    pass


class ErrorMessage(Exception):
    """Raisable error message"""

    def __init__(self, msg):
        """Sets the text"""
        super().__init__()
        self._msg = msg

    def __str__(self):
        """Returns the message"""
        return self._msg


class APIError(ErrorMessage):
    """Indicates a user error"""

    pass


class OutOfContext(ErrorMessage):
    """Indicates that an operation that requires being
    within a with statement was executed outside of it
    """

    pass


def fail(err, *msgs, exit_code=3):
    """Prints error messages to stderr and exit"""

    print('\033[91m\033[1m', end='', file=stderr)  # Red and bold
    print(err, end='', file=stderr)
    print('\033[0m', end=' ', file=stderr)
    print(*msgs, file=stderr)

    exit(exit_code)


def subproc_fail(*msgs):
    """Prints subprocess error messages to stderr and exit"""

    fail('SUBPROCESS ERROR', *msgs, exit_code=3)


def ask(question, default=False, yes=('y', 'yes')):
    """Ask a question and return True on yes or else False"""

    if default:
        suffix = ' [Y/n]: '
    else:
        suffix = ' [y/N]: '

    try:
        reply = input(question + suffix)
    except KeyboardInterrupt:
        return False
    else:
        if not reply:
            return default
        else:
            return reply.lower() in yes


def sudo(cmd, verbose=False):
    """Run a command as root using sudo"""

    output = None if verbose else DEVNULL
    result = run(
        '/usr/bin/sudo -n {}'.format(cmd), shell=True,
        stdin=DEVNULL, stdout=output, stderr=output)
    result.check_returncode()


def getdata(tid, cid, user, passwd, verbose=False):
    """Get data from web API"""

    client = APIClient(user, passwd, cid, tid)

    try:
        location = client.location

        print('Determined terminal location:')
        print()
        print(location)
        print()

        if ask('Is this correct?'):
            if verbose:
                print('Retrieving OpenVPN data')
            else:
                print('Please wait...')

            vpndata = client.vpndata
        else:
            fail('Setup aborted by user')
    except InvalidCredentials:
        fail('INVALID CREDENTIALS',
             'Your user name and / or password are incorrect')
    except Unauthorized:
        fail('UNAUTHORIZED',
             'You are not authorized to set up this terminal')
    except APIError as api_err:
        fail('WEB API ERROR', api_err)
    except KeyboardInterrupt:
        print()
        fail('Setup aborted by user')
    else:
        return vpndata


def configure(tid, cid, vpndata, verbose=False):
    """Performs the terminal configuration"""

    with Configurator(tid, cid, vpndata) as configurator:
        if verbose:
            print('Installing OpenVPN configuration')

        try:
            configurator.configure_openvpn()
        except CalledProcessError:
            subproc_fail('Installation of OpenVPN configuration failed')

        if verbose:
            print('Enabling OpenVPN')

        try:
            configurator.enable_vpn()
        except CalledProcessError:
            subproc_fail('Enabling of OpenVPN client failed')

        if verbose:
            print('Restarting OpenVPN')

        try:
            configurator.restart_vpn()
        except CalledProcessError:
            subproc_fail('Restart of OpenVPN client failed')

        if verbose:
            print('Waiting for OpenVPN server to start')

        sleep(VPN_GRACETIME)

        if verbose:
            print('Checking OpenVPN connection')

        try:
            configurator.test_vpn()
        except CalledProcessError:
            subproc_fail('Cannot contact OpenVPN server')

        if verbose:
            print('Installing', HOSTNAME_FILE_DST)

        try:
            configurator.configure_hostname()
        except CalledProcessError:
            subproc_fail('Installation of', HOSTNAME_FILE_DST, 'failed')

        if verbose:
            print('Disabling on-screen warning')

        try:
            configurator.disable_warning()
        except CalledProcessError:
            subproc_fail('Disabling of on-screen warning failed')

        print()
        print('Setup completed successfully')

        if ask('Do you want to reboot now?'):
            run('/usr/bin/sudo -n /usr/bin/reboot', shell=True)
        else:
            print('Okay, not rebooting',
                  'You can reboot any time by pressing',
                  '[CTRL]+[ALT]+[DEL]', sep='\n')
            exit(0)


def reset(verbose=False):
    """Resets the system's configuration"""

    for op, cmd in (
            ('reset hostname', HOSTNAME_RESET),
            ('remove digital signage data', DIGSIG_DATA_CLEAN),
            ('disable OpenVPN service', VPN_ACTION.format('disable')),
            ('disable application', APPLICATION_SERVICE.format('disable')),
            ('enable on-screen warning', UNCONFIGURED_SERVICE.format(
                'enable'))):
        try:
            sudo(cmd, verbose=verbose)
        except CalledProcessError as cpe:
            fail('Could not {}'.format(op))


def hidslcfg(options):
    """HOMEINFO Digital Signage Linux configurator

    Maintainer: Richard Neumann <r.neumann@homeinfo.de>

    Usage:
        hidslcfg <ident> [--user=<user_name>] [--verbose]
        hidslcfg [options]

    Options:
        --tid=<terminal_id>  Specifies the physical terminal identifier
        --cid=<customer_id>  Specifies the customer identifier
        --user=<user_name>   Specifies the setup user's name
        --verbose            Be gassy
        -h --help            Show this page
    """
    verbose = options['--verbose']
    ident = options['<ident>']

    if ident is None:
        tid = options['--tid']
        cid = options['--cid']
    else:
        try:
            tid, cid = ident.split('.')
        except ValueError:
            fail('INVALID IDENT',
                 'Identifier must be like <tid>.<cid>')

    user = options['--user']

    try:
        if cid is None:
            cid = input('Customer ID: ')
        if tid is None:
            tid = input('Terminal ID: ')
        if not user:
            user = input('User name: ')

        passwd = getpass('Password: ')
    except KeyboardInterrupt:
        print()
        fail('Configuration aborted by user')
    else:
        # Call API
        vpndata = getdata(tid, cid, user, passwd, verbose=verbose)
        configure(tid, cid, vpndata, verbose=verbose)


def hidslreset(options):
    """HOMEINFO Digital Signage Linux resetter

    Maintainer: Richard Neumann <r.neumann@homeinfo.de>

    Usage:
        hidslreset [options]

    Options:
        --verbose            Be gassy
        -h --help            Show this page
    """
    verbose = options['--verbose']

    try:
        reset(verbose=verbose)
    except KeyboardInterrupt:
        print()
        fail('Reset aborted by user')


class TerminalAddress():
    """Terminal address data container"""

    TEMPLATE = (
        'Street:        {street}\n'
        'House number:  {house_number}\n'
        'ZIP code:      {zip_code}\n'
        'City:          {city}\n'
        'Annotation:    {annotation}')

    def __init__(self, s):
        """Generate terminal address from a string"""
        try:
            location = loads(s)
        except (TypeError, ValueError):
            print('Unexpected API reply')
            location = {}

        self.street = location.get('street', '(unknown)')
        self.house_number = location.get('house_number', '(unknown)')
        self.zip_code = location.get('zip_code', '(unknown)')
        self.city = location.get('city', '(unknown)')
        self.annotation = location.get('annotation', '-')

    def __str__(self):
        """Converts the address into a human readable form"""
        return self.TEMPLATE.format(
            street=self.street,
            house_number=self.house_number,
            zip_code=self.zip_code,
            city=self.city,
            annotation=self.annotation)


class APIClient():
    """Class to retrieve data from the web API"""

    PROTO = 'https'
    HOST = 'tls.homeinfo.de'
    PATH = '/termgr/setup'
    VERSION = '3.0'

    def __init__(self, user, passwd, cid, tid):
        """Initialize with credentials"""
        self.user = user
        self.passwd = passwd
        self.cid = cid
        self.tid = tid

    def __call__(self, action):
        """Contact the API with the respective
        user name, password and action call
        """
        params = {
            'user_name': self.user,
            'passwd': self.passwd,
            'action': action,
            'cid': self.cid,
            'tid': self.tid,
            'client_version': self.VERSION}

        try:
            reply = get(self._url, params=params)
        except ConnectionError:
            fail('CONNECTION ERROR', 'Check your internet connection')
        else:
            if reply.status_code == 200:
                return reply
            elif reply.status_code == 401:
                if reply.text == 'Invalid credentials':
                    raise InvalidCredentials()
                else:
                    raise Unauthorized()
            else:
                raise APIError(reply.text)

    @property
    def _url(self):
        """Reutrns the API URL"""
        return '{0}://{1}{2}'.format(self.PROTO, self.HOST, self.PATH)

    @property
    def location(self):
        """Gets the terminal location"""
        return TerminalAddress(self('location').text)

    @property
    def vpndata(self):
        """Gets the terminal's VPN keys and configuration"""
        return self('vpn_data').content


class Configurator():
    """Terminal configurator"""

    def __init__(self, tid, cid, vpndata, verbose=False):
        """Sets VPN configuration"""
        self.tid = tid
        self.cid = cid
        self.vpndata = vpndata
        self.verbose = verbose
        self._tmpdir = None

    def __enter__(self):
        self._tmpdir = mkdtemp()
        vpndata_path = join(self._tmpdir, VPN_ARCHIVE)

        with open(vpndata_path, 'wb') as vpndata_file:
            vpndata_file.write(self.vpndata)

        return self

    def __exit__(self, *_):
        rmtree(self._tmpdir)
        self._tmpdir = None

    def configure_openvpn(self):
        """Installs the OpenVPN configuration"""
        if self._tmpdir is not None:
            # Clean up OpenVPN config
            with suppress(CalledProcessError):
                sudo('/usr/bin/rm /etc/openvpn/*', verbose=self.verbose)

            # Unpack OpenVPN archive
            chdir(self._tmpdir)
            sudo(VPN_INST, verbose=self.verbose)
        else:
            raise OutOfContext('Not within with statement')

    def enable_vpn(self):
        """Enables the OpenVPN service"""
        sudo(VPN_ACTION.format('enable'), verbose=self.verbose)

    def restart_vpn(self):
        """Restarts the OpenVPN service"""
        sudo(VPN_ACTION.format('restart'), verbose=self.verbose)

    def test_vpn(self):
        """Tests the OpenVPN connection to the OpenVPN server"""
        output = None if self.verbose else DEVNULL
        result = run(
            PING_HOST.format(VPN_SERVER), shell=True,
            stdin=DEVNULL, stdout=output, stderr=output)
        result.check_returncode()

    def configure_hostname(self):
        """Configures the system's hostname"""
        if self._tmpdir is not None:
            chdir(self._tmpdir)
            hostname = '{tid}.{cid}'.format(tid=self.tid, cid=self.cid)

            with open(HOSTNAME_FILE_SRC, 'w') as hostname_tmp:
                hostname_tmp.write(hostname)

            sudo(HOSTNAME_INST, verbose=self.verbose)
        else:
            raise OutOfContext('Not within with statement')

    def disable_warning(self):
        """Disables the on-screen unconfigured warning"""
        sudo(UNCONFIGURED_SERVICE.format('disable'), verbose=self.verbose)


if __name__ == '__main__':
    try:
        from docopt import docopt
    except ImportError:
        fail('"docopt" not available', 'CLI mode not available.', exit_code=4)
    else:
        if geteuid() == 0:
            fail('Refusing to run as root!')
        else:
            script_name = basename(__file__)

            if script_name == 'hidslcfg':
                hidslcfg(docopt(hidslcfg.__doc__))
            elif script_name == 'hidslreset':
                hidslreset(docopt(hidslreset.__doc__))
            else:
                fail('Script name "{}" is invalid'.format(script_name))
